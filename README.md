<!-- <div style="display: flex; justify-content: center;">
  <img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/brewscape.png" alt="Brewscape Logo">
</div> -->

<div align="center">
	
![](./image/brewscape.png)

</div>

# ☕ Brewscape - 카페로그
### "공부하기 좋은 카페 없나? 커피가 맛있는 카페 없나?"

#### 카페로그는 이런 분들을 위한 서비스입니다
* 📚 공부나 작업을 위한 조용한 카페를 찾고 계신 분
* ☕ 커피 맛이 특별하고 자체 로스팅한 원두를 판매하는 카페를 찾는 미각의 소유자
* 🎨 개성있고 분위기 있는 인테리어의 카페를 선호하는 분
* 📝 나만의 카페 탐방 기록을 남기고 싶은 카페 매니아

#### 카페로그에서는 이런 것들을 할 수 있어요
* 🔒 소셜 로그인을 사용해서 서비스를 간편하게 시작해 보세요
* 🔍 네이버 지도 API를 활용한 실시간 카페 검색으로 있는 카페만 찾아줘요
* ⭐ 방문한 카페에 대한 별점과 리뷰 작성을 할 수 있어요
* 🏷️ 카페의 특징을 태그로 분류하고 검색해서 내 취향에 맞는 카페를 찾아보세요
* 💾 작성 중인 리뷰의 내용을 자동 임시저장으로 안전하게 보관이 가능해요
* 📸 카페의 분위기와 멋진 라떼아트를 사진으로 기록하고 공유해 보세요
* 🔖 마음에 드는 카페는 스크랩해서 쉽게 찾아볼 수 있어요
<br>

## 📅 개발 기간
#### `2024.12.13 ~ 2025.2.6 (2개월)`

<br>

## 🏃 팀원 소개
<table>
  <tr>
    <td align="center"><a href="https://github.com/acoldbottle">김병찬</a></td>
    <td align="center">문남경</td>
    <td align="center"><a href="https://github.com/florence1920">이승헌</a></td>
    <td align="center"><a href="https://github.com/rough78">임용태</a></td>
    <td align="center"><a href="https://github.com/leejuyeon-star">이주연</a></td>
  </tr>
  <tr>
    <td align="center">Backend</td>
    <td align="center">UI/UX Design</td>
    <td align="center">Frontend</td>
    <td align="center">Frontend</td>
    <td align="center">Backend</td>
  </tr>
  <tr>
    <td align="center">kimbc715@gmail.com</td>
    <td align="center">luna7252@naver.com</td>
    <td align="center">jetaime21212@gmail.com</td>
    <td align="center">lim7897@gmail.com</td>
    <td align="center">kkobucks@naver.com</td>
  </tr>
  <tr>
    <td align="center">
	<img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/profile/byoungchan.png" alt="chan" width="100">    
    </td>
    <td align="center">
	    <img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/profile/moon.png" alt="moon" width="100">    
    </td>
    <td align="center">
        <img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/profile/leeseungheon.jpg" width="100" alt="lsh"/>  
    </td>
    <td align="center">
        <img src="https://raw.githubusercontent.com/cafeLogProject/README/refs/heads/main/image/profile/limyongtae.jpg" width="100" alt="yongtae"/>  
    </td>
    <td align="center">
      <img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/profile/leejuyeon.jpg" alt="juyeon" width="100">
    </td>
  </tr>
</table>



<br>

## 🔍 주요 기능

<table>
  <tr>
    <td align="center"><strong>카페 검색</strong><br><img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/video/cafe_search.gif" width="40%"></td>
    <td align="center"><strong>카페 상세페이지</strong><br><img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/video/cafe_detail.gif" width="40%"></td>
  </tr>
  <tr>
    <td align="center"><strong>리뷰 필터링 조회</strong><br><img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/video/review_filter.gif" width="40%"></td>
    <td align="center"><strong>리뷰 작성</strong><br><img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/video/review_write.gif" width="40%"></td>
  </tr>
  <tr>
    <td align="center"><strong>리뷰 임시저장</strong><br><img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/video/review_draft.gif" width="40%"></td>
    <td align="center"><strong>회원가입, 로그인</strong><br><img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/video/login.gif" width="40%"></td>
  </tr>
  <tr>
    <td align="center"><strong>카페 스크랩</strong><br><img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/video/cafe_scrap.gif" width="40%"></td>
    <td align="center" colspan="2"><strong>마이페이지</strong><br><img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/video/mypage_review_scroll.gif" width="40%"></td>
  </tr>
  <tr>
    <td align="center"><strong>프로필 수정</strong><br><img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/video/profile_edit.gif" width="40%"></td>
  </tr>
</table>
<br>

<br>

## 📚 기술 스택

<h3>프론트엔드</h3>
<table>
  <tr>
    <td><img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/fe/react.svg" width="100"></td>
    <td><img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/fe/typescript.svg" width="100"></td>
    <td><img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/fe/vite.png" width="100"></td>
    <td><img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/fe/reactquery.png" width="100"></td>
    <td><img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/fe/zustand.jpg" width="100"></td>
  </tr>
  <tr>
    <td>React</td>
    <td>TypeScript</td>
    <td>Vite</td>
    <td>React Query</td>
    <td>Zustand</td>
  </tr>
</table>

<table>
  <tr>
    <td><img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/fe/scss.png" width="100"></td>
  </tr>
  <tr>
    <td>SCSS</td>
  </tr>
</table>


<h3>백엔드</h3>
<table>
  <tr>
    <td><img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/be/java.png" width="100"></td>
    <td><img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/be/gradle.png" width="100"></td>
    <td><img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/be/spring_boot.png" width="100"></td>
    <td><img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/be/oauth2.jpeg" width="100"></td>
    <td><img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/be/ss.png" width="100"></td>
  </tr>
  <tr>
    <td>Java 21</td>
    <td>Gradle</td>
    <td>Spring Boot</td>
    <td>Oauth2</td>
    <td>Spring Security</td>
  </tr>
</table>

<table>
  <tr>
    <td><img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/be/jpa.png" width="100"></td>
    <td><img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/be/queryDsl.jpg" width="100"></td>
    <td><img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/be/redis.png" width="100"></td>
    <td><img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/be/mysql.png" width="100"></td>
    <td><img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/be/elasticache.png" width="100"></td>
  </tr>
  <tr>
    <td>Spring Data JPA</td>
    <td>QueryDSL</td>
    <td>Redis</td>
    <td>MySQL 8</td>
    <td>ElastiCache</td>
  </tr>
</table>

<table>
  <tr>
    <td><img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/be/mockito.png" width="100"></td>
    <td><img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/be/junit.png" width="100"></td>
  </tr>
  <tr>
    <td>Mockito</td>
    <td>Junit 5</td>
  </tr>
</table>

<h3>DevOps</h3>
<table>
  <tr>
    <td><img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/devops/actions.png" width="100"></td>
    <td><img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/devops/docker.png" width="100"></td>
    <td><img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/devops/ec2.png" width="100"></td>
    <td><img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/devops/rds.png" width="100"></td>
  </tr>
  <tr>
    <td>Github Actions</td>
    <td>Docker</td>
    <td>AWS EC2</td>
    <td>AWS RDS</td>
  </tr>
</table>

<h3>협업툴</h3>
<table>
  <tr>
    <td><img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/work/github.png" width="100"></td>
    <td><img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/work/notion.png" width="100"></td>
    <td><img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/work/figma.png" width="100"></td>
    <td><img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/work/discord.png" width="100"></td>
  </tr>
  <tr>
    <td>Github</td>
    <td>Notion</td>
    <td>Figma</td>
    <td>Discord</td>
  </tr>
</table>


<br>

## 🌟 주요 기능 구현
- [김병찬]
	- 로그인 관련 기능
   		- OAuth2를 활용한 소셜로그인(구글, 페이스북, 네이버)
  	- 프로필 관련 기능
  		- 내 정보 수정, 조회
		- 닉네임 중복 체크
  	- 카페 관련 기능
	  	- 네이버 검색 API를 활용하여 전국에 있는 카페 검색
		- 카페 저장, 조회
  	- 스크랩 관련 기능
		- 내가 스크랩한 카페 리스트 조회
		- 카페 스크랩 추가, 해제
  	- 스프링 시큐리티를 사용한 인증, 인가 기능
		- JWT 토큰 발급, 재발급
- [이승헌]
    - 마이페이지 관련 기능
        - 내 정보 조회, 수정
        - 프로필 이미지 조회, 수정
    - UI 컴포넌트 관련 기능
        - react-modal, react-toastify 사용
- [임용태]
    - 인증 관련 기능
        - React-Router를 사용하여 Protected Route 설정
        - 인증 확인 및 Redirect
    - 카페 관련 기능
        - 카페 검색, 저장
        - 카페 상세 조회 및 상태에 따른 리뷰작성 버튼 표시
    - 리뷰 관련 기능
        - 리뷰 작성(날짜, 별점, 태그 컴포넌트)
        - 리뷰 정렬, 태그 필터링
    - 리뷰 임시저장 관련 기능
        - 리뷰 임시저장 및 불러오기
  	    - 임시저장 백엔드와 준실시간 연동
    - 이미지 관련 기능
        - 이미지 업로드 컴포넌트 구현(PhotoUploader)
        - 이미지 업로드 Progress에 따른 UI 동기화(업로드 중/완료)
- [이주연]
  	- 리뷰 관련 기능
  	   	- 리뷰 최신순/별점순 조회
		- 리뷰 태그 필터링 조회
  	   	- 카페의 모든 리뷰 조회
  	   	- 내 모든 리뷰 조회
		- 리뷰 CRUD
  	- 리뷰 임시저장 관련 기능
  	  	- 내 임시저장 조회
 		- 임시저장 CRUD
	- 이미지 관련 기능
 		- 리뷰 이미지 CRUD
		- 임시저장 리뷰 이미지 CRUD
		- 프로필 이미지 CRUD
  	- 닉네임 랜덤 생성 기능



<br>

## ⚽ 트러블 슈팅
<details>
<summary> 김병찬 </summary>
	
<details>
<summary>Mixed Content 문제</summary>
<br>

# 🤔문제 발생
- HTTPS로 설정된 웹사이트에서 HTTP로 제공되는 리소스가 로드되어 Mixed Content 발생
  <img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/be/chan/screenshot1.png">

# 🔍원인 분석
- https://{도메인}/api/auth/login 로 요청을 보냈을때, 응답은 정상적으로 이루어졌지만, 리소스 중 일부가 HTTP로 로드
- 스프링 시큐리티의 기본 설정에 따라 리소스(favicon 등)가 HTTP로 호출
- 보안상의 이유로 브라우저는 SSL(HTTPS)이 적용되지 않은 리소스 호출을 허용 X → Mixed Content 발생

# ⛏해결 과정
- Nginx 설정 확인
    - 모든 HTTP 요청을 HTTPS 로 리다이렉트하게 했는지 확인. 없으면 추가
    <img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/be/chan/screenshot2.png">

- Nginx 설정에 프록시 헤더 추가
    - location 블록에서 X-Forwarded-Proto 헤더를 설정하여, 클라이언트의 요청 프로토콜을 Tomcat에 전달
    <img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/be/chan/screenshot3.png">
    
- application.yml 파일에 Tomcat이 X-Forwarded-Proto 헤더를 통해 요청의 프로토콜을 인식하도록 설정 추가
```
server:
  tomcat:
    remoteip:
      protocol-header: x-forwarded-proto
```
- 실행 결과
    - favicon.ico 가 HTTP → HTTPS 로 변경
    - Mixed Content 발생 X
    <img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/be/chan/screenshot4.png">

- 스프링 시큐리티의 favicon URL을 HTTPS로 변경해도 되지만 파비콘 뿐만 아니라 다른 리소스들도 있을 수 있으므로 이 방법은 사용 X

# 💎결론
- HTTPS를 사용하는 경우 HTTP 리소스를 호출하지 않거나, Nginx를 통해 HTTPS로 리다이렉트함으로써 모든 리소스가 HTTPS를 통해 안전하게 로드되며, Mixed Content 에러가 발생하지 않게 되었음

# 참고
- https://velog.io/@giant_toothpick/mixed-content-error-처리하기-with.-Nginx
- https://velog.io/@jamie/mixed-content-error

</details>
</details>

<details>
<summary> 이승헌 </summary>
<details>
<summary>SCSS Module을 전역적으로 사용하는 방법</summary>
<br/>

# 🤔 문제 발생
    
React에서 SCSS Modules를 사용하면 클래스가 로컬 스코프화되어 컴포넌트 간 스타일 충돌을 방지하는 장점이 있다. 하지만 특정 스타일을 전역적으로 적용해야 할 경우, 어떻게 관리하는 것이 가장 효과적일까?
    
# 🔍 원인 분석
    
- SCSS Modules를 사용하면 기본적으로 클래스명이 로컬화되어, 다른 컴포넌트에서 동일한 클래스를 재사용하기 어렵다.
- 특정 클래스를 전역적으로 사용하려면 `:global`을 활용할 수 있지만, 이를 여러 파일에서 남용하면 어떤 클래스가 전역적으로 적용되는지 한눈에 파악하기 어려워진다.
- 프로젝트가 커질수록 스타일 관리가 어려워지고, 유지보수성이 떨어질 가능성이 있다.
    
# ⛏ 해결 과정
    
이 문제를 해결하기 위해 **SCSS 7-1 패턴**을 도입하여 스타일을 체계적으로 관리했다.
    
1. **전역 스타일과 컴포넌트 스타일을 분리**
    - 전체 프로젝트에서 공통적으로 적용되는 스타일(글꼴, 색상, 레이아웃 등)은 `styles` 디렉터리에 모아 관리했다.
    - 개별 컴포넌트의 스타일은 SCSS Modules를 활용하여 유지보수성을 높였다.
2. **버튼 및 공통 컴포넌트 스타일 통합**
    - 버튼, 입력 필드 등 공통 컴포넌트에서 사용되는 파일을 분리했다.
    - 이를 필요할 때만 가져와 사용할 수 있도록 `@import`를 활용했다.
3. **SCSS 변수를 활용한 일관된 디자인 시스템 구축**
    - 색상, 폰트 크기, 여백 등의 값을 `_variables.scss`에 정의하여 일관된 스타일을 유지했다.
    - 예를 들어, `primaryColor`를 변경하면 전체 버튼 색상이 한 번에 적용되도록 설정했다.
        
    
# 💎 결론
    
SCSS Modules의 장점을 유지하면서도 전역 스타일을 효과적으로 관리하려면 **전역 스타일과 로컬 스타일을 분리하는 전략이 필수적**이다.

- SCSS 7-1 패턴을 적용하여 전역 스타일을 별도로 관리하면 유지보수가 쉬워진다.
- 버튼, 폰트, 색상 등의 공통 스타일은 별도의 SCSS 파일로 분리하여 중복을 최소화한다.
- SCSS 변수를 적극 활용하여 일관된 스타일 시스템을 유지하면 확장성과 유지보수성이 향상된다.

이러한 방식을 적용하면 SCSS Modules의 로컬 스코프화 장점을 살리면서도, 전역적인 스타일을 효율적으로 관리할 수 있다.
    
</details>
</details>
<details>
<summary> 임용태 </summary>
<details>
<summary>리뷰 임시저장 기능에서의 API 무한 호출 문제</summary>
<br>
    
# 🤔문제 발생

- 리뷰 임시저장 기능 구현 중 API가 무한히 호출되는 현상이 발생
        
- 상태 업데이트와 API 호출이 서로를 트리거하는 순환 의존성 문제 발생
    
# 🔍원인 분석
    
- useEffect 내에서의 함수 재생성 문제

- API 호출 함수가 상태 업데이트를 트리거하고, 상태 업데이트가 다시 API 호출을 트리거하는 순환 구조 형성

# ⛏해결 과정
    
- useCallback을 사용하여 API 호출 함수 메모이제이션

- 불필요한 의존성 제거 및 의존성 배열 최적화
    
- API 관련 로직을 custom hook으로 분리하여 재사용성 향상
    
# 💎결론
    
- useCallback과 의존성 배열 최적화를 통해 무한 호출 문제 해결

- 커스텀 훅을 사용하여 코드 재사용성과 유지보수성 향상
</details>
<details>
<summary>이미지 업로드 상태 관리 문제</summary>
<br>

# 🤔문제 발생

- 사진 업로드 기능 구현 시 API 호출과 상태 관리의 강한 결합으로 인한 문제 발생
- Store 내부에서 직접 API 훅을 사용하려 할 때 훅 규칙 위반 문제 발생
업로드 진행 상태와 실패 처리의 복잡성 증가

# 🔍원인 분석

- 즉각적인 상태 반영 필요성:

  - 파일 선택 즉시 미리보기 생성 필요
  - 업로드 시작과 동시에 진행 상태 표시 필요
  - API 응답 즉시 성공/실패 상태 반영 필요

- 복잡한 상태 변화 시나리오:
  - 선택된 파일 → 임시 상태(미리보기) → 업로드 중 → 성공/실패

- 실패 처리의 복잡성:
  - 업로드 실패 시 이전 상태로 정확한 복구 필요
  - 여러 파일 동시 업로드 시 부분 실패 처리 필요

# ⛏해결 과정

- API 주입 패턴 도입:

  - Store 생성 함수에 API 메서드 주입
  - API 호출과 상태 관리 로직 분리

- 상태 관리 신뢰성 확보:

  - API 호출과 상태 업데이트 동기화
  - 업로드 실패 시 안전한 상태 복구
  - 동시 업로드 시 각 파일의 상태 추적

- 사용자 경험 개선:
  - 즉각적인 피드백 제공
  - 업로드 진행 상태의 실시간 반영
  - 오류 상황에서도 안정적인 동작



# 💎결론

- API 호출과 상태 관리 로직을 분리하여 유지보수성 향상
- 상태 관리의 신뢰성을 확보하고 안정적인 파일 업로드 처리 구현
- API와 상태 관리의 분리로 재사용 가능한 구조

</details>
</details>
<details>
<summary> 이주연 </summary>
<details>
<summary>Collection 타입 조회/저장시 쿼리 다수 호출 문제 해결 (N+1 문제)</summary>
<br>

# 🤔문제 발생

- 한 엔티티에 일반 Collection타입(@ElementCollection) 필드값을 지정했을때, 저장/수정/조회시 쿼리가 다수 호출되는 문제 발생

- **조회 시**: 모든 Review엔티티의 tag 값을 조회할 때,  아래 쿼리가 **Review의 개수만큼** 반복 실행됨 → N+1 문제
    
    <img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/be/jy/image_1-1.png">
    

- **저장 시**: Review의 tag를 저장할 때, 아래 쿼리가 **tag의 개수만큼** 반복 실행됨
    
    <img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/be/jy/image_1-2.png">
    

# 🔍원인 분석

### 쿼리 분석

- 위의 쿼리를 보면 review_tags라는 테이블 때문에 저장/조회할때 쿼리가 많이 실행되는것을 알 수 있음
- review_tags 테이블은 자의로 생성한 기억이 없어서 어떤 이유로 생성되었는지 찾아보니, 아래 사진처럼 review 엔티티의 필드에 @CollectionTable로 지정되어 있었다.. 충분히 고민하지 않고 어노테이션을 적용하여 문제가 발생했던 것!
    
    <img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/be/jy/image_1-3.jpg">
    

### Collection의 매핑 테이블이 문제다!

- review_tags는 review와 tag간의 외래키를 저장하는 테이블임
    - **테이블이 왜 생겼을까?**
        - Collection 타입은 고유 식별자가 없기 때문에, 아래 사진처럼 부모 엔티티의 식별자를 매핑한 테이블(review_tags)이 생성됨
            
            <img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/be/jy/image_1-4.png">
            
    - 이로 인해, **Collection 타입을 저장할때마다 매핑 테이블에 식별자를 저장하는 쿼리가 실행되고, 조회할때마다 매핑테이블을 조회하는 쿼리가 실행됨 →** N+1 문제
    

# ⛏해결 과정

## 💡 **@ElementCollection 필드 조회시 N+1 문제 해결과정**

### ✅ 시도**1 : FetchType.EAGER로 변경하기**

- 기본적으로 @ElementCollection은 FetchType.LAZY로 작동하는데, 이를 EAGER로 변경하여 Collection값을 모두 로드한 후 조회
- 단점 : EAGER로 설정하면 부모 엔티티만 조회할 때도 자식인 Collection 값까지 같이 조회되므로 **N+1 문제가 발생**할 수 있음

### ✅ 시도**2 : fetch join 사용하기**

- EAGER 대신 LAZY + fetch join 조합 사용
- **단점** : QueryDSL을 사용할땐 @ElementCollection 필드의 Q객체를 자동으로 생성하지 않아join/fetch join을 사용할 수 없음 → 가독성을 위해 QueryDSL을 사용하여 구현해야 했으므로 보류

### ✅ 시도**3 : @ElementCollection 타입 대신 Embedded 타입 사용하기**

- 테이블을 따로 생성하지 않고 부모 엔티티 테이블 내에 데이터를 넣는 방식
    
    아래 사진처럼 리스트에 들어갈 모든 경우의 수를 저장해야 한다.
    
    <img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/be/jy/image_1-5.png">
    
- **장점** : 다른 방법보다 구현이 쉬움
- **단점** :
    - 리스트 값이 무엇인지 예측할 수 없으면 사용하기 어려움
    - 리스트값들을 변수로 바꾸는 것이기 때문에 리스트 값이 많을 경우 테이블 칼럼 수가 많아져 아래 사진처럼 보기 안좋음
    
    <img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/be/jy/image_1-6.png">
    

### ✅ 시도**4 : @ElementCollection 타입 대신 Entity 타입 사용하기**

- **장점** : join을 사용하여 N+1문제 해결 가능
- **단점** :
    - 방법3보다 구현 난이도 높음
    - 저장 쿼리에서 쿼리 과다문제가 발생하므로 batch insert를 사용해야 함



## 💡 **@ElementCollection 필드 저장시 쿼리 과다 문제 해결과정**

### ✅ 시도 : **batch insert 사용하기 → 실패**

- 적용해보았지만 작동하지 않음
    - 쿼리 로그를 통해 batch insert가 작동하지 않음을 확인
        
        <img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/be/jy/image_1-7.png">
        

        → 서칭해보니 Hibernate는 @ElementCollection에 대해 Batch insert가 작동하지 않는다고 함

참고링크 : [https://stackoverflow.com/questions/61102607/why-doesnt-hibernate-batch-inserts-of-fields-annotated-with-elementcollection](https://stackoverflow.com/questions/61102607/why-doesnt-hibernate-batch-inserts-of-fields-annotated-with-elementcollection)

## ❓**그럼 언제 @ElementCollection 타입을 사용하는게 좋은가?**

- @ElementCollection은 ****저장/수정/조회 모든 면에서 쿼리가 추가 발생하므로 가급적 사용하지 않는게 좋음
- 엔티티보다 간단한 구현이 필요할 때 사용
- 저장/수정/조회가 빈번하지 않은 배열값일 때 사용

# 💎결론

- @ElementCollection 필드를 사용할 경우 저장/수정/조회 면에서 쿼리가 다량 발생했다. 이를 해결하기 위해 Entity 타입이나 Embedded 타입을 사용해야 한다.
- 해당 프로젝트에서는 리스트 값이 많아 Entity 타입을 선택했고, join을 사용하여 N+1 문제를 해결했다.
</details>




<details>
<summary>고아 데이터 처리 문제 해결</summary>
<br>

# 🤔문제 발생

- 사용자가 **게시글에 이미지를 업로드한 후 작성 취소하면**, 이미지가 삭제되지 않고 서버에 남아버리는 문제 발생

# 🔍원인 분석

### **현재 상태**

- 사용자가 게시글을 작성하는 동안 **DB에는 게시글이 저장되지 않음**.
- **게시글 저장 API**와 **이미지 저장 API**가 **분리**되어 있음.
- 게시글을 삭제하면 **해당 게시글의 이미지도 함께 삭제됨**.

### **문제 발생 시나리오**

1. 사용자가 **게시글을 작성하면서 이미지 업로드**
2. **이미지가 먼저 서버에 저장됨**
3. 사용자가 **게시글 작성 취소**
4. 이미지가 삭제되지 않아 **고아 상태로 남음**

# ⛏해결 과정

## ❓**고아 이미지 문제를 어떻게 해결할까?**

### ✅ **방법 1: 고아 이미지를 주기적으로 삭제**

- **이미지 저장 시, 저장 시간을 함께 기록**
- 일정 기간이 지난 후, 게시글에 연결되지 않은 이미지를 **정기적으로 삭제**
- **단점**: 일정 간격으로 삭제 작업을 수행해야 함

### ✅ **방법 2: 게시글 임시저장 기능 추가**

- **새 게시글 작성시 바로 임시저장 게시글 저장**
- 이미지 저장 시, 임시저장 게시글과 연결
- **사용자가 작성 취소 시, 임시저장 게시글과 이미지를 함께 삭제**
- **장점**: 애초에 고아 이미지 발생 x

### 📌 결론

프로젝트 특성상 **임시저장 기능이 필요했기 때문에 방법 2로 결정!**



## ❓ **임시저장 게시글을 어떻게 저장할까?**

### **✅ 방법 1: 임시저장 전용 테이블을 따로 만들기**

- **장점**
    - 임시저장 데이터만 별도로 관리 가능
        
        → **주기적 삭제 기능 추가 시 구현이 쉽고 처리 속도 빠름**
        
- **단점**
    - 게시글을 공개로 전환할 때 **임시저장 테이블에서 공개 테이블로 이동해야함
    →** 이 과정에서 삭제 쿼리 + 생성 쿼리 발생 → **저장 속도 저하**

### **✅ 방법 2: 기존 게시글 테이블에 저장 & 임시저장 여부 필드 추가**

- **장점**
    - 임시저장 외에도 (삭제, 신고, 비공개 등) **다양한 상태 관리 가능**
- **단점**
    - 게시글을 검색할 때 **임시저장인지, 공개된 글인지 매번 필터링 필요**
    - 쿼리 실행 부담 증가 ****→ 조회 속도 저하

### 📌 결론

프로젝트 특성상 **검색/조회가 더 빈번**하므로, 저장/수정보다 조회 성능을 고려하여 **1번째 방법 채택!**



## **🛠구축 후 깨달은 방법 1의 문제점**

### **1️⃣ 개발 시간이 많이 걸림**

- 게시글과 연관된 엔티티가 있다면, **임시저장 게시글과도 연관된 엔티티를 새로 만들어야 함 →** 개발 난이도 증가
- 임시 해결책: 연관 엔티티를 컬렉션 자료형으로 변경
    → 저장/조회/수정 시 **추가적인 쿼리 발생, 결국 속도 저하**

### **2️⃣ 코드의 유연성이 떨어짐**

- 게시글 상태(삭제, 신고, 비공개 등)를 추가하려면 **별도 테이블을 계속 만들어야 함**
    
    → 결국 기존 테이블에 상태 필드를 추가하는 방향으로 가게 됨
    
    → 그럴바에 **임시저장 여부도 처음부터 상태 필드로 관리하는 게 더 낫다고 판단**
    

### 3️⃣ **조회 속도 저하 우려는 크지 않음**

- 사실 임시저장 여부를 확인하는 쿼리는 **대규모 데이터가 아니면 성능 문제 없음**

### 📌 결론

**다음번엔 방법 2를 사용하자!**

# 💎결론

- 임시저장 기능을 도입해 고아 이미지 문제를 해결했지만, 임시저장 전용 테이블 방식은 개발 복잡도와 유지보수 측면에서 비효율적이었다.
- 다음에는 기존 게시글 테이블에 상태 필드를 추가하는 방식으로 설계하여 유연성과 개발 효율성을 높이자!

</details>


<details>
<summary>태그 조회 문제 해결</summary>
<br>

# 🤔문제 발생

- **여러 개의 태그를 가진 게시물을 여러 개의 태그로 조회하는 API**를 제작해야 했다.
- **지정한 모든 태그를 포함한 게시물만 조회**해야 했다.
- IN 쿼리로 시도했지만 **태그 중 하나만 포함되어도 조회되는 문제 발생**
    
    ```java
    public List<Review> tagSearch(List<Integer> selectedTagIds){
        return queryFactory
                        .from(review)
                        .where(tag.tagId.in(selectedTagIds))
                .fetch();
    }
    ```
    

# ⛏해결 과정

### ✅ 시도 1: groupBy + having 사용 → 실패

```java
public List<Review> tagSearch(List<Integer> selectedTagIds){
    return queryFactory
                    .from(review)
                    .where(tag.tagId.in(selectedTagIds))
                    .groupBy(review.id)
                    .having(tag.tagId.count().eq(selectedTagIds.size()))
            .fetch();
}
```

- 구현 실패
    - 일부 태그만 포함되더라도 **태그 개수만 맞으면 조회되는 문제**가 발생.
    
    → 지정한 모든 태그를 포함하는 게시물만 조회하는 ****조건을 만족하지 못함
    

### ✅ 시도 2: contains() 활용 → 실패

```java
public List<Review> tagSearch(List<Integer> selectedTagIds)
    return queryFactory
                    .from(review)
                    .where(review.tags.contains("tag1"))
                    .fetch();
}
```

- 구현 실패
    - contains()는 특정 1개의 태그 포함 여부만 확인 가능.
    - **태그 여러개 포함 여부는 확인 불가능**하여 조건을 만족하지 못함
    

### ✅ 시도 3: 태그 개수별 개별 조회 함수 작성 → 실패

- 1개 태그 조회, 2개 태그 조회... 태그 개수에 따른 조회하는 함수를 여러개 만드는 방법
- 문제점
    - **함수 개수가 태그 개수만큼 늘어나 좋지 않음**

### ✅ 시도 4: QueryDSL 동적 쿼리 활용 → 성공!

- 동적 쿼리를 이용하여 태그의 개수에 따라 태그 조회 조건이 변하는 단 한개의 함수 제작
    
    ```java
    public List<Review> tagSearch(List<Integer> selectedTagIds)
        return queryFactory
                .from(review)
                .where(eqTags(selectedTagIds))
                .fetch();
    }
    ```
    

- `BooleanExpression`을 활용하여 **태그 개수에 따라 WHERE 쿼리를 동적으로 조절하도록 함**
    
    ```java
    // 모든 태그가 포함된 리뷰면 true
    private BooleanExpression eqTags(List<Integer> selectedTagIds){
        return selectedTagIds!= null && !selectedTagIds.isEmpty() ? Expressions.allOf(selectedTagIds.stream().map(this::isContainsTagId).toArray(BooleanExpression[]::new)) : null;
    }
    
    // 한 태그가 포함된 리뷰면 true
    private BooleanExpression isContainsTagId(Integer selectedTagId) {
        return review.tagIds.contains(selectedTagId);
    }
    ```
    

- 장점
    - join 쿼리를 사용하지 않음 → 쿼리 복잡도 낮음
    - tag 필드가 Collection 타입인 경우도 사용 가능함
- 단점
    - 조회하려는 태그가 많을 경우 WHERE절이 늘어남 → 성능 저하
    - contains는 인덱스를 활용하지 않아 모든 행 검사가 일어남 → 리뷰 수가 많을 경우 성능 크게 저하
- 언제 사용하는게 좋은가?
    - tag 필드가 Collection 타입인 경우 → 인덱스가 없으므로 가장 효율적
    - 

### ✅ 시도 5: join + groupBy + having 활용 → 성공!

- 여러개의 값들을 모두 포함하는 조회를 할때 join과, groupBy, having을 사용하면 문제를 손쉽게 해결할 수 있다.
    
    ```java
    public List<Review> tagSearch(List<Integer> selectedTagIds)
        return queryFactory
                .from(review)
                .join(tag).on(tag.review.id.eq(review.id))
                .where(tag.tagId.in(selectedTagIds))
                .groupBy(review.id)
                .having(tag.tagId.count().eq(selectedTagIds.size()))
                .fetch();
    }
    ```
    
- 쿼리 동작 방식
    1. join을 이용하여 review테이블과 tag테이블을 연결
    2. where문을 이용하여 요청한 태그가 하나라도 포함된 review만 1차 필터링
    3. groupBy로 tag를 그룹화 후 having으로 요청한 총 태그의 개수가 같은 review만 조회

- 장점
    - join을 사용하므로 조회하려는 태그가 많아져도 성능 저하되지 않음
    - 인덱스를 사용하여 조회 가능 → 리뷰 수가 많아져도 성능 저하되지 않음
- 단점
    - join을 사용하므로 불필요한 연산 가능성 있음 → review와 tag에 인덱스가 존재하므로 문제없음
    - tag 필드가 **Collection 타입**인 경우 QueryDSL에서 join이 불가능하므로 사용 불가
        
        → 이 경우, QueryDSL 대신 네이티브 SQL을 활용해야 함
        

### ❓동적 쿼리와 join+groupBy+having 성능 비교 (시도 4 vs 시도 5)

- 거의 모든 면에서 join+groupBy+having의 성능이 더 좋음
- tag 필드가 Collection 타입인 경우 동적 쿼리의 성능이 더 좋음

# 💎결론

- **QueryDSL을 활용하여 여러개의 태그를 포함하는 게시물 조회하는 함수를 제작하였다.**
- 제작 방법은 2가지가 있다.
    1. 동적 쿼리를 사용하는 방법
    2. join + groupBy + having을 사용하는 방법
- 성능은 거의 모든 면에서 두번째 방법이 좋았다. 다만 Collection 타입의 필드를 사용할 경우에는 첫번째 방법을 사용하는것이 좋다.
</details>



<details>
<summary>DTO 형변환시의 코드 가독성 문제 해결</summary>
<br>

# 🤔문제 발생

- Tuple을 사용하여 DTO를 변환하는 과정에서 코드가 복잡해지고, 가독성이 떨어지며 유지보수에 어려움이 발생했다.

- **문제의 코드**
    - 수동으로 DTO에 매핑하는 구조 → **코드 복잡, 가독성 저하**
    
    ```jsx
    public ShowReviewResponse findShowReviewResponseById(Long reviewId) {
        List<Tuple> results = queryFactory
                    .from(review)
                .select(review, tag.tagId, reviewImage.id, user)
                .leftJoin(reviewImage).on(review.id.eq(reviewImage.review.id))
                .leftJoin(review.user).fetchJoin()
                .leftJoin(tag).on(review.id.eq(tag.review.id))
                .where(review.id.eq(reviewId))
                .fetch();
    
        Map<Long, ShowReviewResponse> reviewMap = new HashMap<>();
        Long reviewId = null;
        for (Tuple tuple : results) {
            Review reviewEntity = tuple.get(review);
            Integer tagId = tuple.get(tag.tagId);
            UUID reviewImageId = tuple.get(reviewImage.id);
            User userEntity = tuple.get(user);
            reviewId = reviewEntity.getId();
    
            ShowReviewResponse res = reviewMap.computeIfAbsent(reviewEntity.getId(), key 
                    -> new ShowReviewResponse(reviewEntity, userEntity));
            if (tagId != null) {
                res.addTagId(tagId);
            }
            if (reviewImageId != null) {
                res.addImageId(reviewImageId);
            }
        }
        return reviewMap.get(reviewId);
    
    }
    ```
    

# ⛏해결 과정

## **✅** 시도 1 : @QueryProjection 사용하기

- @QueryProjection을 활용하여 Q타입 DTO 객체를 자동으로 생성하고, 이를 **select()**에서 바로 사용
- **🛠 리팩토링 결과**
    
    ```java
    public ShowReviewResponse findShowReviewResponseById(Long reviewId) {
        return queryFactory
                .select(new QShowReviewResponse(
                        review,
                        set(reviewImage.id),    
                        set(tag.tagId)
                ))
                .from(review)
                .leftJoin(reviewImage).on(review.id.eq(reviewImage.review.id))
                .leftJoin(review.user).fetchJoin()
                .leftJoin(tag).on(review.id.eq(tag.review.id))
                .where(review.id.eq(reviewId))
                .groupBy(review.id, reviewImage.id, tag.tagId)
                .fetchOne();
    }
    ```
    

- **문제 발생** : **카테시안 곱 문제가 발생**
    - DISTINCT로는 해결할 수 없음
        - 카테시안 곱에서 발생한 중복 데이터는 해결하지 못한다!
        - left join에 의해 여러 reviewImage와 여러 tag가 하나의 review에 대해 각각 다른 행으로 생성
            
            → reviewImage.id와 tag.tagId는 개별적으로 그룹화되어 중복된 데이터 생성됨
            



## **✅** 시도 2 : QueryDSL의 groupBy().transform() 사용하기

### ❓일반적인 groupBy와 무엇이 다른가?

- **그룹화 시점이 다르다!**
    - 일반적인 groupBy는 그룹화 로직을 **DB에서 수행**
    - groupBy().transform()은 그룹화 로직을 **메모리에서 수행**
        
        → **카테시안 곱 문제를** 간단하게 해결할 수 있음
        

### ❓카테시안 곱 문제를 어떻게 해결할까?

- 메모리에서 그룹화를 수행하기 때문에 복잡한 DB 쿼리 대신 java 라이브러리를 이용할 수 있음
    
    → java의 set() 함수 이용하여 중복 제거 후 DTO로 변환 가능
    

### ❓사용시 성능 저하 문제는 없을까?

- **그룹화할 데이터의 양이 적은 경우에만 사용해야 한다!**
    - 그룹화 로직이 메모리에서 처리되므로 데이터를 한 번에 메모리에 로드해야 함
        
        → 데이터 양이 많으면 CPU와 메모리에 부담을 줄 수 있음
        
    - **이번 문제의 경우..**
        - 함수 호출시 메모리에 로드되는 최대 행 개수가 25개(카테시안 곱으로 인한 중복 데이터 포함)로, 데이터 양이 적어 성능에 큰 영향 없음
        



## **🛠** 최종 리팩토링 결과

```jsx
public ShowReviewResponse findShowReviewResponseById(Long reviewId) {
    return queryFactory
            .from(review)
            .leftJoin(reviewImage).on(review.id.eq(reviewImage.review.id))
            .leftJoin(review.user).fetchJoin()
            .leftJoin(tag).on(review.id.eq(tag.review.id))
            .where(review.id.eq(reviewId))
            .transform(
                    groupBy(review.id).as(
                            new QShowReviewResponse(
                                    review,
                                    set(reviewImage.id),    // 카테시안 곱 문제 방지를 위해 set 사용
                                    set(tag.tagId)          // 카테시안 곱 문제 방지를 위해 set 사용
                            )
                    )
            )
            .get(reviewId);
}
```

# 💎결론

- **QueryDSL의 groupBy().transform()**을 사용하여 DTO로 변환함으로써 가독성을 높이고, 카테시안 곱 문제도 해결할 수 있었다.
</details>



<details>
<summary>동적 쿼리 조회 문제 해결</summary>
<br>

# 🤔문제 발생

- 특정 조건에 맞는 리뷰만 조회하는 필터링 조회 기능을 제작해야 했고, **Native Query**로 작성함
    - 문제의 난잡한 코드..
        
        ```bash
        public interface ReviewRepository extends JpaRepository<Review, Long> {
        
            @Query(value = "SELECT r.id FROM review r " +
                            "WHERE (:currentRating IS NULL OR r.rating < :currentRating) " +
                            "AND r.created_at < :createdAt " +
                            "ORDER BY " +
                            "CASE WHEN :sortMethod = 'HIGH_RATING' THEN r.rating END DESC, " +
                            "CASE WHEN :sortMethod = 'NEW' THEN r.created_at END DESC, " +
                            "LIMIT :pageSize OFFSET :offset", 
                    nativeQuery = true)
            List<Long> findReviewIdsByFilters(
                @Param("currentRating") Double currentRating, 
                @Param("createdAt") LocalDateTime createdAt, 
                @Param("sortMethod") String sortMethod, 
                @Param("pageSize") int pageSize, 
                @Param("offset") int offset
            );
        }
        ```
        

- 문제 1: 조회 조건이 다양하여 쿼리문이 길어짐
    
    **→ 가독성, 유지보수성이 떨어지는 문제 발생**.
    
- 문제 2: 특정 조건을 제외하고 호출해야 할 경우, 그 조건을 제외한 함수를 따로 만들어야 함
    
    **→ 코드 재사용성이 어려워지는 문제 발생**
    

# 🔍원인 분석

### 조회 필터링 종류

- 정렬 방식 : 최신순, 별점 높은 순
- 특정 별점 이하의 리뷰만 조회 **(정렬방식이 별점 높은 순일 경우만 사용)**
- 리턴할 리뷰 개수 지정 가능
- 특정 timestamp 이후의 리뷰만 조회

### 조회 필터링 특징

- 정렬 방식에 따라 필요한 조건이 달라진다 → **조건을 동적으로 처리할 방법이 필요**
- 필터링 종류가 다양하다. → **함수를 쪼개어 가독성을 높여야 함**

# ⛏해결 과정

## 💡 QueryDSL 사용하기

- **QueryDSL의 특징**
    
    QueryDSL은 사용자 요청에 따라 동적으로 쿼리를 생성할 수 있는 기능을 제공. 
    
    이를 통해 복잡한 쿼리문을 효율적으로 관리하고 코드 리팩토링을 진행할 수 있음.
    

    

- **ORDER BY 쿼리를 동적으로 만들기**
    - **QueryDSL의 OrderSpecifier 타입**을 사용하여,
    요청된 정렬 방식에 맞춰 동적으로 ORDER BY 쿼리를 구성.
        
        ```java
        // 최신순 or 별점 높은순으로 정렬
        private OrderSpecifier[] createOrderSpecifier(String sortMethod){
            List<OrderSpecifier> orderSpecifiers = new ArrayList<>();
            switch (sortMethod) {
                case "NEW" :
                    orderSpecifiers.add(new OrderSpecifier(Order.DESC, review.createdAt));
                    return orderSpecifiers.toArray(new OrderSpecifier[orderSpecifiers.size()]);
                case "HIGH_RATING" :
                    orderSpecifiers.add(new OrderSpecifier(Order.DESC, review.rating));
                    orderSpecifiers.add(new OrderSpecifier(Order.DESC, review.createdAt));
                    return orderSpecifiers.toArray(new OrderSpecifier[orderSpecifiers.size()]);
                default:
                    throw new ReviewInvalidSortError(ErrorCode.REVIEW_INVALID_SORT_ERROR);
            }
        }
        ```
        
    - 위 함수를 사용하여 **가독성과 코드 재사용성을 높인 모습**
        
        ```java
        public List<Long> findReviewIdsByFilters(String sortMethod) {
            OrderSpecifier[] orderSpecifiers = createOrderSpecifier(sortMethod);
            return queryFactory
                    // 코드생략.. 
                    .orderBy(orderSpecifiers)
                    // 코드 생략..
            }
        ```
        

- WHERE 쿼리를 동적으로 만들기
    - **QueryDSL의 BooleanExpression 타입**을 사용하여,
    요청된 정렬 방식에 맞춰 동적으로 WHERE 쿼리를 구성.
        
        ```java
        // 특정 별점 이하의 리뷰만 조회
        // 리뷰의 별점 <= 주어진 별점값 이면 true
        private BooleanExpression isLowerThenRating(Integer currentRating) {
            return currentRating != null ? review.rating.loe(currentRating) : null;
        }
        
        // 특정 timestamp 이후의 리뷰만 조회
        // 리뷰의 생성시간 <= 주어진 생성시간 이면 true
        private BooleanExpression isBeforeCreatedAt(LocalDateTime createdAt) {
            return createdAt != null ? review.createdAt.loe(createdAt) : null;
        }
        ```
        
    - 위 함수를 사용하여 **가독성과 코드 재사용성을 높인 모습**
        
        ```java
        public List<Long> findReviewIdsByFilters(String sortMethod, Integer currentRating, LocalDateTime createdAt, Pageable pageable) {
            return queryFactory
                                // 코드 생략..
                    .where(
                            isLowerThenRating(currentRating),
                            isBeforeCreatedAt(createdAt)
                    )
                                // 코드 생략..
            }
        ```
        



## 📌 **개선된 코드**

- 리팩토링 전

```java
public interface ReviewRepository extends JpaRepository<Review, Long> {
    @Query(value = "SELECT r.id FROM review r " +
                    "WHERE (:currentRating IS NULL OR r.rating < :currentRating) " +
                    "AND r.created_at < :createdAt " +
                    "ORDER BY " +
                    "CASE WHEN :sortMethod = 'HIGH_RATING' THEN r.rating END DESC, " +
                    "CASE WHEN :sortMethod = 'NEW' THEN r.created_at END DESC, " +
                    "LIMIT :pageSize OFFSET :offset", 
            nativeQuery = true)
    List<Long> findReviewIdsByFilters(
        @Param("currentRating") Double currentRating, 
        @Param("createdAt") LocalDateTime createdAt, 
        @Param("sortMethod") String sortMethod, 
        @Param("pageSize") int pageSize, 
        @Param("offset") int offset
    );
}
```

- 리팩토링 후

```java
public List<Long> findReviewIdsByFilters(String sortMethod, Integer currentRating, LocalDateTime createdAt, Pageable pageable) {
    OrderSpecifier[] orderSpecifiers = createOrderSpecifier(sortMethod);
    return queryFactory
            .select(review.id)
            .from(review)
            .where(
                    isLowerThenRating(currentRating),
                    isBeforeCreatedAt(createdAt)
            )
            .orderBy(orderSpecifiers)
            .offset(pageable.getOffset())
            .limit(pageable.getPageSize())
            .fetch();
    }
```

# 💎결론

- QueryDSL을 활용하여 동적인 쿼리 생성을 유연하게 처리함으로써, **가독성, 유지보수성, 코드 재사용성이** 개선되었다.
</details>



<details>
<summary>테스트 코드 작성해야 할까?</summary>
<br>

# 🤔문제 발생

- **테스트 코드 작성의 필요성을 느끼지 못함**
    - **postman으로도 충분하다!**
        - postman을 통해 api 호출해보면서 테스트를 진행할 수 있다고 생각
        - 사전에 예외 처리와 로그를 작성하면 버그가 났을때 충분히 해결이 가능하다고 생각

# ⛏해결 과정

## Postman만으로는 부족한 이유

- **API가 많아질수록 테스트에 시간과 노력이 많이 든다**
    - 모든 예외를 적어놓고, 코드 수정 시 해당 예외들을 일일이 실행하여 테스트해야 함.
        - ex) "리뷰 등록" API의 service 계층 로직을 수정하면 그에 대한 모든 예외들을 실행하여 오류를 검사해야 함.
        
        <img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/be/jy/image_6-1.png">
        
        - **문제 발생** : 만약 리뷰 엔티티의 "태그" 필드를 수정하면, 그 엔티티를 사용하는 모든 API와 예외들을 하나하나 실행해야 함. 이 작업은 시간이 많이 걸리고 귀찮음

## **테스트코드를 만들면서 느낀 테스트 코드의 필요성**

- **기존 로직을 수정할 때** 발생하는 새로운 버그를 쉽게 추적할 수 있다!
    - 예를 들어, A개발자가 만든 로직을 B개발자가 수정할때 중요 로직을 실수로 빠뜨려 예상하지 못한 버그가 발생
        - A개발자가 테스트 코드를 작성해놓았다면, B개발자는 테스트 코드를 통해 쉽게 문제를 찾을 수 있음
- 테스트 코드가 **문서 역할**을 함
    - 테스트 코드는 코드 자체가 문서가 되어, 타 개발자가 로직의 흐름을 한눈에 파악할 수 있게 해줌.

→ 결국 **테스트코드는 내 코드를 수정할 미래의 나 자신 혹은 동료개발자를 위해 필요**

## 프로젝트를 진행하며 느낀 테스트 코드의 결함

- **내 코드의 결함은 테스트 코드로 잡아낼 수 없다!**
    - 내가 겪은 문제 : 통합 테스트를 거친 뒤 API를 완성했지만, 내가 발견하지 못한 버그가 동료 개발자에 의해 발견됨
        
        → 내가 만드는 테스트코드는 **내가 인지하는 범위 내에서만 테스트하기 때문에** 내가 인지하지 못하는 버그는 잡아내지 못한다. 
        
- 해결 : 동료 개발자도 내 로직의 테스트를 해주어야 함 → QA 역할 필요

# 💎결론

- **테스트코드는 내 코드를 수정할 미래의 나 자신 혹은 동료개발자를 위해 필요하다**
- **Postman보다 테스트코드를 작성하는것이 장기적으로는 효율적이다.**
- **테스트 코드는 문서 역할도 하여** 동료 개발자에게 유용하다.
- 내가 만든 테스트코드만으로는 에러를 커버할 수 없으므로 **동료 개발자의 QA를** 통해 보완해야 한다.
</details>

<details>
<summary>어떤 로직이 테스트 코드가 필요할까?</summary>
<br>

# 🤔문제 발생

- 기능 구축 후 통합 테스트 코드 작성을 시도했지만, 모든 부분을 테스트하기엔 시간이 부족해 테스트가 필요한 부분만 추려야 했음. 하지만 어떤 기준으로 추려야 할지 고민

# ⛏해결 과정

## ❓어떤 로직이 테스트가 필요할까?

- 가성비 있는 로직 : “**테스트코드를 짜는 시간 < 버그를 찾는 시간**” 인 로직
- 테스트가 꼭 필요한 로직 : 심각한 오류를 방지해야 하는 로직

## ❓**가성비 있는 로직의 특징?**

- **문서화가 필요한 로직**
    - 로직이 복잡한 경우
    - 통상적인 로직 규칙과는 다르게 구현한 경우
        - 기존에 널리 사용되는 규칙이나 패턴을 벗어난 구현은 새로운 개발자가 이해하기 어렵다. 이러한 로직을 문서화하면 향후 수정 시 실수를 줄일 수 있다.
        - ex) Util 함수
    - 동료 개발자가 내 코드를 수정할 때 조심해야 하는 부분이 존재하는 경우
        - 예를 들어,
            
            ```jsx
            public List<ShowReviewResponse> findUserReviews(String username, ShowUserReviewRequest request) {
                User user = userRepository.findByUsername(username).orElseThrow(() ->{
                    throw new UserNotFoundException(username, ErrorCode.USER_NOT_FOUND_ERROR);
                });
                Pageable pageable = PageRequest.of(0, request.getLimit());
                return reviewRepository.searchByUser(user, request.getTimestamp(), pageable);
            }
            ```
            
            위 함수에서 `PageRequest.*of*(0, request.getLimit())` 의 첫번째 매개변수가 반드시 0이어야 한다. 만약 동료 개발자가 모르고 0이 아닌 다른 값을 넣어버리면 오류는 나지 않지만 잘못된 값이 반환돤다. 
            
            → **예외가 발생하지 않는 버그이기 때문에 문서화 필요**
            

## ❓테스트가 꼭 필요한 로직의 특징?

- **본인이 알지 못하는 심각한 오류를 방지할 수 있는 로직**
    - 내가 만드는 테스트코드는 **내가 인지하는 범위 내에서만 테스트하기 때문에** 내가 인지하지 못하는 버그는 잡아내지 못한다.
    - **동료 개발자**가 해당 로직에 대한 테스트 코드를 작성한다면, 내가 미처 발견하지 못한 오류를 찾을 수 있다.
    - 심각한 오류 예시 : 저장/수정/삭제가 들어간 로직

# 💎결론

- 테스트 코드가 필요한 부분은 두가지다.
    - **문서화해야 할 정도로 복잡한 로직**
        
        → 이 경우, 로직을 짠 본인이 테스트 코드를 작성해야 한다.
        
    - **심각한 오류가 발생할 가능성이 있는 로직**
        
        → 이 경우, 본인이 아닌 동료 개발자가 테스트 코드를 작성해야 한다.
</details>


<details>
<summary>Static 메소드 mocking 문제 해결</summary>
<br>

# 🤔문제 발생

### static 메소드를 mocking 시도했지만 실패함

- **상황**
    - ImageUtil.saveImage 실행하기에는 추가 세팅이 많이 요구되어 mocking이 필요했음
    
    ```java
    @Service
    public class ReviewImageService {
        @Transactional
        public void addReviewImage(String username, Long reviewId, MultipartFile multipartFile) {
            // 코드 생략 ...
            ImageUtil.saveImage(ImageUtil.REVIEW_IMAGE_PATH, newImageId.toString(), multipartFile);
            // 코드 생략 ...
        }
    }
    ```
    
    - 아래의 public static void인 saveImage 메소드 mock필요
        
        ```java
        public class ImageUtil {
            public static void saveImage(String path, String imageId, MultipartFile file) {
                        // 코드 생략 ...
            }
            }
        ```
        

- **문제**
    - 아래와 같은 방법으로 mocking을 시도
    
    ```java
    public class AddReviewImageTest {
        @MockitoBean
        ImageUtil imageUtil;
        @Autowired
        ReviewImageService reviewImageService;
        
        @Test
        @DisplayName("리뷰 이미지 파일 저장 성공")
        public void addReviewImageSuccess() {
            // when
            reviewImageService.addReviewImage(username, reviewId, imageFile);
    
            // then
                    // 코드 생략 ...
        }
    }
    ```
    
    - 테스트 실행 결과, mock처리가 되지 않은 채 동작

# 🔍원인 분석

- Static 메소드는 Bean으로 등록되지 않기 때문에 @MockitoBean을 사용한 mocking이 불가능하다.

# ⛏해결 과정

## ✅과정 1 : MockedStatic 사용하기

- MockedStatic을 사용하여 정적 메소드를 mock하는 방법을 발견
    
    (참고 : [https://www.testim.io/blog/mocking-static-methods-mockito/](https://www.testim.io/blog/mocking-static-methods-mockito/))
    

<img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/be/jy/image_8-1.png">

- 구현 코드
    
    ```java
    public class AddReviewImageTest {
        @Autowired
        ReviewImageService reviewImageService;
        
        @Test
        @DisplayName("리뷰 이미지 파일 저장 성공")
        public void addReviewImageSuccess() {
            //given
            try (MockedStatic<ImageUtil> imageUtil = mockStatic(ImageUtil.class)) {
                imageUtil.when(()-> ImageUtil.saveImage(anyString(), anyString(), any(MultipartFile.class))).thenReturn(null);
                
                // when
                reviewImageService.addReviewImage(username, reviewId, imageFile);
        
                // then
                            // 코드 생략 .. 
            }
        }
    }
    ```
    
    - try문으로 감싸 try문이 끝나면 mock 객체를 해제하도록 함. 그렇지 않으면 다른 테스트 함수에서도 mock객체를 사용하게 됨
    
        
    
- **문제 발생**

<img src="https://raw.githubusercontent.com/cafeLogProject/README/main/image/be/jy/image_8-2.png">

위 방법은 리턴 형식이 void가 아닌 경우만 가능했음



## ✅과정 2 : thenReturn 대신 thenAnswer 사용하기

- 위의 방법을 사용하면서 void 메소드를 mock하기 위해 thenReturn 대신 thenAnswer를 활용

```java
public class AddReviewImageTest {
    @MockitoBean
    ImageUtil imageUtil;
    @Autowired
    ReviewImageService reviewImageService;
    
    @Test
    @DisplayName("리뷰 이미지 파일 저장 성공")
    public void addReviewImageSuccess() {
        //given
        try (MockedStatic<ImageUtil> imageUtil = mockStatic(ImageUtil.class)) {
            imageUtil.when(()-> ImageUtil.saveImage(anyString(), anyString(), any(MultipartFile.class))).thenAnswer(i -> {
                System.out.println("모킹된 ImageUtil.save() 호출");
                return null;
            });
            
            // when
            reviewImageService.addReviewImage(username, reviewId, imageFile);
    
            // then
                        // 코드 생략 .. 
        }
    }
}
```

(참고 : [https://unluckyjung.github.io/testcode/2021/12/20/Mockito-StaticMethod-Mocking/](https://unluckyjung.github.io/testcode/2021/12/20/Mockito-StaticMethod-Mocking/))

# 💎결론

- static 메소드 mock처리시 MockedStatic을 사용하고, static void 메소드인 경우 thenAnswer를 사용하여 처리한다.
</details>






</details>

## 🔗 프로젝트 문서
* [노션](https://www.notion.so/18fc5e41552d81bfa985c870e5c2fed4)
* [포스트맨](https://www.postman.com/cafelog/cafelog-team/overview)
* [피그마](https://www.figma.com/design/UPFpjUYoJa0nx1GiQNktp0/%5B2025-%ED%8C%80-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%5D-%EC%BB%A4%ED%94%BC-%EA%B8%B0%EB%A1%9D?node-id=0-1&t=0iUqRTZvxP7KlhpO-1)

